# 事件处理 #
***
JavaScript采用了异步事件驱动编程模型。在这种程序设计风格下，当文档、浏览器、元素或与之相关的对象发生某些有趣的事情时，Web浏览器就是产生事件。

事件类型（event type）是一个用来说明放生什么类型事件的字符串。

事件目标（event target）是发生的事件或与之相关的对象。当讲事件时，我们必须同时指明类型和目标。

事件处理程序（event handler）或事件监听程序（event listener）是处理或响应事件的函数。应用程序通过指明事件类型和事件目标，在Web浏览器中注册它们的事件处理程序函数。

事件对象（event object）是与特定事件相关且包含有关该事件详细信息的对象。事件对象作为参数传给事件处理程序。

事件传播（event propagation）是浏览器决定哪个对象触发其事件处理程序的过程。对于单个对象的特定事件，必须是不能传播的。当文档元素上发生某个类型的事件时，它们会在文档树上向上传播或'冒泡'。

事件传播的另一个形式成为事件捕获（event capturing），在容器上注册的特定处理程序有机会在事件传播到真实目标前拦截它。IE8之前不支持事件捕获，所以不常用它。但是当处理鼠标拖放事件时，捕获或'夺取'鼠标事件的能力是必须的。

一些事件有与之相关的默认操作。例如超链接上的click事件，浏览器的默认操作是按照链接加载新页面。事件处理程序可以通过返回一个适当的值、调用事件对象的某个方法或设置事件对象的某个属性来阻止默认操作。

## 事件类型 ##

### 事件分类 ###

事件大概可以分成几类：

* 依赖于设备的输入事件  

	有些事件和特定的输入设备直接相关。比如鼠标和键盘，也有触摸事件。

* 独立于设备的输入事件

	有些输入事件没有直接相关的特定输入设备。例如click事件表示激活了一个链接、按钮或其它文档元素，通常是鼠标单击实现，但是也能通过键盘或者触摸屏等实现。

* 用户界面事件
	
	用户界面事件是较高级的事件，通常出现在定义Web应用用户界面的HTML表单元素上。包括文本输入域获取键盘焦点的focus事件、用户表单元素显示值改变change事件和用户单击表单中的提交按钮submit事件。

* 状态变化事件

	有些事件不是由用户活动而是由网络或浏览器活动触发的，用来表示某种生命周期或相关状态的变化。比如Window对象的load事件。

* 特定API事件

	HTML5及相关规范定义的大量Web API都有自己的事件类型。

* 计时器和错误处理程序

	计时器(timer)和错误处理程序(error handler)属于客户端JavaScript异步编程模型的部分，并有相似的事件。

### 传统事件类型 ###

#### 表单事件 ####

表单和超链接都是网页中最早支持脚本的元素。当提交表单和重置表单时，``<form>``元素会分别触发submit和reset事件。当用户和类按钮表单元素（包括单选按钮和复选按钮）交互时，它们会发生click事件。当用户通过输入文字、选择选项或者选择复选框来改变相应表单元素的的状态时，这些通常维护某种状态的表单元素会触发change事件。对于文本输入域，只有用户和表单元素完成交互并通过tab或者单击的方式移动焦点到其它元素上才会触发change事件。响应通过键盘改变焦点的表单元素在得到和失去焦点时会分别触发focus和blur事件。

通过事件处理程序能取消submit和reset事件的默认操作，某些click事件也是如此。focus事件和blur事件不会冒泡，但其它所有表单事件都可以。

无论用户何时输入文字（通过键盘或剪切和粘贴）到``<textarea>``和其它文本输入表单元素，除IE外的浏览器都会触发input事件。不像change事件，每次文字插入都会触发input事件。但是input事件对象没有指定输入文本的内容。

#### window事件 ####

window事件是指事件的发生与浏览器窗口本身而非窗口中显示的任何特定文档内容相关。

load事件是这些事件中最重要的一个，当文档和其它所有外部资源（图片等等）完全加载并显示给用户时就会触发它。

unload事件和load相对，用户离开当前文档转向其它文档时会触发它。unload事件处理程序可以保存用户的状态，但他不能用于取消用户转向其它地方。beforeunload事件和unload类似，但是它能提供询问用户是否确定离开当前页面的机会。

window的onerror属性有点像事件处理程序，当JavaScript出错时就会触发它。

像``<img>``元素这样的单个文档元素也能为load和error事件注册处理程序。当外部资源完全加载或者发生阻止加载的错误时就会触发它们。

表单元素的focus和blur事件也能用作window事件，当浏览器窗口从操作系统中得到或者拾取键盘焦点时会触发它们。

当用户调整浏览器窗口大小或滚动它时会触发resize和scroll事件。scroll事件也能在任何可以滚动的文档元素上触发，比如设置css的overflow属性的元素。

#### 鼠标事件 ####

当用户在文档上移动或单击鼠标时都会产生鼠标事件。这些事件会在鼠标指针所对应的最深嵌套元素上触发，但他们会冒泡直到文档最顶层。传递给鼠标事件处理程序的事件对应对象有属性集，它们描述了当事件发生时鼠标的位置和按键状态，也指明了当时是否有辅助键按下。clientX和clientY属性指定了鼠标在窗口坐标中的位置，button和which属性指定了按下的鼠标键是哪个。

用户每次移动或拖动鼠标时，会触发mousemove事件。当用户按下或释放鼠标按键时会触发mousedown和mouseup事件。通过注册mousedown和mousemove事件处理程序可以探测和响应鼠标的拖动。

在mousedown和mouseup事件队列之后，浏览器也会触发click事件。如果用户在相当短的时间内连续两次单击鼠标按键，跟在第二个click事件之后是dbclick事件。当单击鼠标右键时，浏览器通常会显示上下文菜单。在显示菜单之前，它们通常会触发contextmenu事件，而取消这个事件就可以阻止菜单的显示。这个事件也是获得鼠标右击通知的简单方法。

当用户移动鼠标指针从而使它悬停到新元素上时，浏览器就会在该元素上触发mouseover事件。当鼠标移动指针从而使它不在悬停在某个元素上时，浏览器就会在该元素上触发mouseout事件。mouseover和mouseout事件和所有鼠标事件一样都会冒泡，但是这会有一些问题，触发事件处理程序时，你需要检查是否真的离开了目标元素还是从这个元素的一个子元素移动到了另一个。有这些事件的不冒泡版本mouseenter和mouseleave。

当用户滚动鼠标滚轮时，浏览器触发mousewheel事件。传递的事件对象属性指定滚轮转动的大小和方向。

#### 键盘事件 ####

当键盘聚焦到web浏览器时，用户每次按下或释放键盘上的按键时都会产生事件。键盘快捷键对于操作系统和浏览器本身有特殊意义，它们经常被操作系统或者浏览器'吃掉'并对JavaScript事件处理程序不可见。无论任何文档元素获取键盘焦点都会触发键盘事件，并且会冒泡到document和window对象。如果没有元素获取焦点，可以直接在文档上触发事件。传递给键盘事件处理程序的事件对象有keyCode字段，它指定按下或释放的键是哪个，出了keyCode，键盘事件对象也有altKey、ctrlKey、mataKey和shiftKey，描述键盘辅助键的状态。

keydown和keyup事件是低级键盘事件，无论何时按下或释放按键，都会触发它们，当keydown事件产生可打印字符时，在keydown和keyup之间会触发另外一个keypress事件。当按下键重复产生字符时，在keyup事件之前可能产生很多keypress事件。keypress是较高级的文本事件，其对象指定产生的字符而非按下的键。


### DOM事件 ###

3级DOM事件规范标准化了不冒泡的focusin和focusout事件来取代冒泡的focus和blur事件，标准化了冒泡的mouseenter和mouseleave事件来取代不冒泡的mouseover和mouseout事件。

3级DOM事件规范定义了keypress事件，但是赞成使用它，而使用称为textinput的新事件。传递给textinput事件处理程序的事件对象不再有难以使用的数字keyCode属性，而又指定输入本文字符串的data属性。textinput事件不是键盘特定事件，无论通过键盘、剪切和粘贴、拖放等方式，每当发生文本输入时就会触发它。

新标准在事件对象中加入新的key属性来简化可以keydown、keyup和keypress事件。对于产生可打印字符的键盘事件，key为生成的文本。对于控制键，key属性将会像标识键的'Enter'等等。

### HTML5事件 ###

HTML5及相关标准定义了大量新的Web应用API，其中许多API都定义了事件。加入用于播放音频和视频的``<audio>``和``<video>``元素。这些元素有很长的事件列表，它们触发各种关于网络事件、数据缓冲状况和播放状态的通知。

HTML5的拖放API允许JavaScript应用参与基于操作系统的拖放操作，实现Web和原生应用间的数据传输。触发拖放事件的事件对象和通过鼠标事件发送的对象类似，其附加属性dataTransfer持有dataTransfer对象，它包含关于传输的数据和其中可用的格式的信息。

HTML5定义了历史管理机制，它允许Web应用同浏览器的返回和前进按钮交互。这个机制设计的事件是hashchange和popstate。这些事件是类似load和unload的生命周期通知事件，它在window对象上触发而非任何单独的文档元素。


### 触摸屏和移动设备事件 ###

许多情况下，触摸屏事件映射到传统的事件类型，但不是每次和触摸屏UI的交互都能模仿鼠标，也不是所有的触摸都可以当做鼠标事件处理。

Safari产生的手势事件用于两个手指的缩放和旋转手势。当手势开始时生成gesturestart事件，而手势结束时生成gestureend事件。在这两个事件之间是跟踪手势过程的gesturechange事件队列。这些事件传递的事件对象有数字属性scale和rotatiaon。scale属性是两个手指之间当前距离和初始距离的比值。rotation属性是指从事件开始手指旋转的角度，它以度为单位，正直表示按照顺时针方向旋转。

手势事件是高级事件，用于通知已经翻译的手势。如果想实现自定义手势，你可以监听低级触摸事件。当手指触摸屏幕时会触发touchstart事件，当手指移动时会触发touchmove事件，而当手指离开屏幕时会触发touchend事件。触摸事件不直接报告触摸的坐标，触摸事件传递的事件对象有一个changedTouches属性，该属性是一个类数组对象，每个元素都描述触摸的位置。

当设备语序用户从竖屏旋转到横屏模式时会在window对象上触发orientationchanged事件，该事件传递的事件对象本身没有用，但是在移动版的Safari中，window对象的orientation属性能给出当前方位，其值是0、90、180或-90.

## 注册事件处理程序 ##

注册事件处理程序有两种基本方式，第一种出现在web初期，给事件目标对象或文档设置属性。第二种方式更新并且更通用，是将事件处理程序传递给对象或元素的一个方法。每种技术都有两个版本，可以在JavaScript代码中设置事件处理程序为对象属性。或对于文档元素，可以在HTML中直接设置相应属性。对于通过方法调用的事件处理程序注册，有一个标准方法，命名为addEventListener()。除IE8及以前的版本所有浏览器都支持，而IE9之前的IE版本支持的是一个叫attachEvent()的不同方法。

### 设置JavaScript对象属性为事件处理程序 ###

注册事件处理程序最简单的方法就是通过设置事件目标的属性为所需事件处理程序函数。事件处理程序属性的名字由'on'后面跟着事件名组成：onclick、onchange等等，这些属性名是区分大小写的，所有的都是小写。

这种事件处理程序注册技术适用所有浏览器常用事件类型。缺点是设计都是围绕着角色每个事件目标对于每种事件类型将最多只有一个处理程序。如果想编写能在任意文档中都能使用的脚本库代码，更好的方式是使用一种不修改或覆盖任何已有注册处理程序的技术。

### 设置HTML标签属性为事件处理程序 ###

用于设置的文档元素事件处理程序属性（property）也能换成对应HTML标签的属性（attribute）。如果这样做，属性值应该是JavaScript代码字符串。这段代码应该是事件处理程序的主体，而非完整的函数声明。

### addEventListener() ###

addEventListener接受三个参数，第一个是要注册的处理程序的事件类型，这个事件类型也是字符串，但它不应该包括用于设置事件处理程序属性的前缀'on'。第二个参数是当指定类型的事件发生时，应该调用的函数。最后一个参数是布尔值，默认为false，如果传递了true，那么函数将注册为捕获事件处理程序，并将在事件不同的调度阶段调用。

addEventListener()为同一个对象注册同一事件类型的多个处理程序函数。当对象上发生事件时，所有该事件类型的注册处理程序都会按照注册的顺序调用。

相对的addEventListener()的是removeEventListener()方法，它同样有三个参数，从对象中删除事件处理程序函数，它常用于临时注册事件处理程序，然后不久就删除它。

### attachEvent() ###

IE9之前的IE不支持addEventListener()和removeEventListener()，IE5以后的版本定义了类似attachEvent()和detachEvent()。attachEvent()和detachEvent(）与addEventListener()和removeEventListener()类似，但是有例外：

* 因为IE的事件模型不支持事件捕获，所有attachEvent()和detachEvent()要求只有两个参数：事件类型和处理程序函数。
* IE的方法第一个参数使用了带'on'前缀的时间处理程序属性名，而非没有前缀的事件类型。
* attachEvent()允许相同的事件处理程序函数注册多次。当特定的事件类型发生时，注册函数的调用次数和注册次数相同。

## 事件处理程序的调用 ##

### 事件处理程序的参数 ###

通常调用事件处理程序时把事件对象作为它们的一个参数。事件对象的属性提供了有关事件的详细信息。例如type属性指定了发生的事件类型。

IE8及以前版本通过设置属性注册事件处理程序，当调用它们时并未传递事件对象。取而代之需要通过全局对象window.event来获得事件对象。

### 事件处理程序的运行环境 ###

当通过设置属性来注册事件处理程序时，这看起来好像是在文档元素上定义了新方法。事件处理程序在事件目标上定义，所以它们作为这个对象的方法来调用。也就是说在事件处理程序内，this关键字指向的是事件目标。

甚至当使用addEventListener()注册时，调用的处理程序使用事件目标作为它们的this值。但是对于attachEvent()来说这是不对的，使用attachEvent()注册的处理程序作为函数调用，它们的this值是全局对象（window）。

### 事件处理程序的作用域 ###

像所有的JavaScript函数一样，事件处理程序从词法上讲也是作用域。它们在其定义的作用域而非调用时的作用域中执行，并且它们能存取那个作用域中的任何一个本地变量。

但是通过HTML属性来注册的事件处理程序是一个例外。它们被转换为能存取全局变量的顶级函数而非任何本地变量。

### 事件处理程序的返回值 ###

通过设置对象属性或HTML属性注册事件处理程序的返回值有时非常有意义。通常返回值false就是告诉浏览器不要执行这个事件相关的默认操作。例如表单提交按钮的onclick事件处理程序能返回false阻止浏览器提交表单。同样当用户输入不合适的字符，输入域上的onkeypress事件处理程序能通过返回false来过滤键盘输入。

事件处理程序的返回值只对通过属性注册的处理程序才有意义。addEventListener(）和attachEvent()注册事件处理程序转而必须preventDefault()方法或设置事件对象的returnValue属性。

### 调用顺序 ###

文档元素或其它对象可以为指定事件类型注册多个事件处理程序。当适当的事件发生时，浏览器必须按照如下规则调用所有的事件处理程序：

* 通过设置对象属性或HTML属性注册的处理程序一直优先调用
* 使用addEventListener()注册的处理程序按照它们的注册顺序调用
* 使用attachEvent()注册的处理程序可能按照任何顺序调用

### 事件传播 ###

当事件目标是window对象或其它一些单独的对象时，浏览器简单的通过调用对象上的适当的处理程序响应事件。当事件目标是文档或文档元素时，情况比较复杂。

在调用在目标元素上注册事件处理程序后，大部分事件会'冒泡'到DOM数根。调用目标的父元素的事件处理，然后调用在目标的祖父元素上注册的事件处理程序。这会一直到document对象，最后到达window对象。事件冒泡为在大量单独文档元素上注册处理程序提供了替代方案，即在共同的祖先元素上注册一个处理程序来处理所有的事件。

发生在文档元素上的大部分事件都会冒泡，值得注意的例外是focus、blur和scroll事件。文档元素上的load事件会冒泡，但它会在Document对象上停止冒泡而不会传播到Window对象。只有当整个文档都加载完毕时才会触发Window对象的load事件。

事件冒泡是事件传播的第三个'阶段'。目标对象本身的事件处理程序调用是第二个阶段。第一个阶段甚至发生才目标处理程序调用之前，称为'捕获'阶段。addEventListener(）把一个布尔值作为第三个参数，如果这个参数是true，则事件处理程序注册为捕获事件处理程序，它会在事件传播的第一个阶段调用。

事件捕获提供了在事件没有送达目标之前查看它们的机会。事件捕获能用于程序调试，或用于后面介绍的事件取消技术，过滤掉事件从而使目标处理程序绝不会被调用。事件捕获常用于处理鼠标拖放，因为要处理拖放事件的位置不能是这个元素内部的子元素。

### 事件取消 ###

在支持addEventListener()的浏览器中，也能通过调用事件对象的preventDefault()方法取消事件的默认操作。

取消事件相关的默认操作只是事件取消中的一种，我们也能取消事件传播。在支持addEventListener()的浏览器中，可以调用事件对象的一个stopPropagation()方法以阻止事件的继续传播，如果在同一对象上定义了其它处理程序，剩下的处理程序将依旧被调用。

## 文档加载事件 ##

大部分Web应用都需要Web浏览器通知它们文档加载完毕和为操作准备就绪的时间。Window对象的load事件就是为了这个目的，load事件直到文档和所有图片加载完毕才发生。然而在文档完全解析之后但在所有图片全部加载完毕之前运行脚本通常是安全的，所以如果基于'load'发生之前的事件触发脚本会提升web应用的启动时间。

当文档加载解析完毕且所有延迟(deferred)脚本都执行完毕时会触发DOMContentLoaded事件，此时图片和异步脚本可能依旧在加载，但是文档已经为操作准备就绪了。

## 鼠标事件 ##

与鼠标相关的事件有不少，除'mouseenter'和'mouseleave'外的所有鼠标事件都能冒泡。链接和提交按钮上的click事件都有默认操作且能够阻止。可以取消上下文菜单事件来阻止显示上下文菜单，但一些浏览器有配置选项导致不能取消上下文菜单。

* click	高级事件，当用户按下并释放鼠标按键或其它方式'激活'元素时触发
* contextmenu 可以取消的事件，当上下文菜单即将出现时触发
* dblclick 当用户双击鼠标时触发
* mousedown 当用户按下鼠标时触发
* mouseup 当用户释放鼠标时触发
* mousemove 当用户移动鼠标时触发
* mouseover 当鼠标进入元素时触发
* mouseout 当鼠标离开元素时触发
* mouseenter 类似mouseover但是不冒泡
* mouseleave 类似mouseout但不冒泡

传递给鼠标事件处理程序的事件对象有clientX和clientY属性，它们指定了鼠标指针相对于包含窗口的坐标。加入窗口的滚动偏移量，就可以把鼠标位置转换成文档坐标。

altKey、ctrlKey、metaKey和shiftKey属性指定了当事件发生时是否有各种键盘辅助键按下。例如，这能让你能够区分普通单击和按着shift键的单击。

button属性指定了当事件发生时哪个鼠标按键按下，但是不同的浏览器给这个属性赋不同的值，所以它很难用。

## 键盘事件 ##

当用户在键盘上按下或释放按键时，会发生keydown和keyup事件。它们由辅助键、功能键和字母数字键产生，如果用户按键事件足够长导致它开始重复，那么在keyup事件到达之前会收到多个keydown事件。

这些事件相关的事件对象都有数字属性keyCode，指定了按下的键是哪个。对于产生可打印字符的按键，keyCode值是按键上出现的主要字符的Unicode编码。

无论shift键处于什么状态，字母键总是产生大写keyCode值，这是因为它们出现在物理键盘上。对于不可打赢键，keyCode属性将是一些其他值。

类似鼠标对象事件，键盘事件对象有altKey，ctrlKey，metakey和shiftKey属性，当事件发生时，如果对应的辅助键被按下，那么它们会被设置为true。

